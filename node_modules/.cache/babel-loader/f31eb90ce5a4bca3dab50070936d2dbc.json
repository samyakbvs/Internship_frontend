{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.prefix = prefix;\nexports.unprefix = unprefix;\nexports.pickErrors = pickErrors;\nexports.filter = filter;\nexports.filterAndMapErrors = filterAndMapErrors;\nexports.remove = remove;\nexports.shift = shift;\nexports.unshift = unshift;\nexports.move = move;\nexports.swap = swap;\nexports.inclusiveMapErrors = inclusiveMapErrors;\nexports.isChildPath = exports.EMPTY_ERRORS = void 0;\n\nvar _omitBy = _interopRequireDefault(require(\"lodash/omitBy\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _paths = require(\"./paths\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar EMPTY_ERRORS = Object.freeze({});\nexports.EMPTY_ERRORS = EMPTY_ERRORS;\n\nvar isChildPath = function isChildPath(basePath, path) {\n  return path !== basePath && (0, _paths.inPath)(basePath, path);\n};\n\nexports.isChildPath = isChildPath;\n\nfunction mapKeys(errors, baseName, fn) {\n  if (errors === EMPTY_ERRORS) return errors;\n  var newErrors = {};\n  var workDone = false;\n  Object.keys(errors).forEach(function (path) {\n    var newKey = path;\n\n    if (isChildPath(baseName, path)) {\n      var matches = path.slice(baseName.length).match(/\\[(\\d+)\\](.*)$/);\n      newKey = fn(+matches[1], matches[2] || '', path);\n      if (!workDone && newKey !== path) workDone = true;\n    }\n\n    newErrors[newKey] = errors[path];\n  });\n  return workDone ? newErrors : errors;\n}\n\nvar prefixName = function prefixName(name, baseName) {\n  return baseName + (!name || name[0] === '[' ? '' : '.') + name;\n};\n\nfunction prefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    result[prefixName(path, baseName)] = errors[path];\n  });\n  return result;\n}\n\nfunction unprefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    var shortened = path.slice(baseName.length).replace(/^\\./, '');\n    result[shortened] = errors[path];\n  });\n  return result;\n}\n\nfunction pickErrors(errors, names) {\n  if (!names.length) return errors;\n  return (0, _pick.default)(errors, names);\n}\n\nfunction filter(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    if (isChildPath(baseName, path)) {\n      result[path] = errors[path];\n    }\n  });\n  return result;\n}\n\nfunction filterAndMapErrors(_ref) {\n  var errors = _ref.errors,\n      names = _ref.names,\n      resolveNames = _ref.resolveNames,\n      _ref$mapErrors = _ref.mapErrors,\n      mapErrors = _ref$mapErrors === void 0 ? pickErrors : _ref$mapErrors;\n  if (!errors || errors === EMPTY_ERRORS) return errors;\n  names = resolveNames ? resolveNames() : names;\n  return mapErrors(errors, names ? [].concat(names) : []);\n}\n\nfunction remove(errors) {\n  for (var _len = arguments.length, basePaths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    basePaths[_key - 1] = arguments[_key];\n  }\n\n  return (0, _omitBy.default)(errors, function (_, path) {\n    return basePaths.some(function (b) {\n      return (0, _paths.inPath)(b, path);\n    });\n  });\n}\n\nfunction shift(errors, baseName, atIndex) {\n  var current = baseName + \"[\" + atIndex + \"]\";\n  return mapKeys(remove(errors, current), baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction unshift(errors, baseName, atIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction move(errors, baseName, fromIndex, toIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (fromIndex > toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // increment everything above the pivot\n\n      if (index >= toIndex && index < fromIndex) return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    } else if (fromIndex < toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // decrement everything above the from item we moved\n\n      if (index >= fromIndex && index < toIndex) return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction swap(errors, baseName, indexA, indexB) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index === indexA) return baseName + \"[\" + indexB + \"]\" + tail;\n    if (index === indexB) return baseName + \"[\" + indexA + \"]\" + tail;\n    return null;\n  });\n}\n\nfunction inclusiveMapErrors(errors, names) {\n  if (!names.length || errors === EMPTY_ERRORS) return EMPTY_ERRORS;\n  var activeErrors = {};\n  var paths = Object.keys(errors);\n  names.forEach(function (name) {\n    paths.forEach(function (path) {\n      if (errors[path] && (0, _paths.inPath)(name, path)) {\n        activeErrors[path] = errors[path];\n      }\n    });\n  });\n  return activeErrors;\n}","map":{"version":3,"sources":["/Users/samyakjain/Desktop/Metacube/Internship_frontend/node_modules/react-formal/lib/utils/ErrorUtils.js"],"names":["exports","__esModule","prefix","unprefix","pickErrors","filter","filterAndMapErrors","remove","shift","unshift","move","swap","inclusiveMapErrors","isChildPath","EMPTY_ERRORS","_omitBy","_interopRequireDefault","require","_pick","_paths","obj","default","Object","freeze","basePath","path","inPath","mapKeys","errors","baseName","fn","newErrors","workDone","keys","forEach","newKey","matches","slice","length","match","prefixName","name","paths","result","shortened","replace","names","_ref","resolveNames","_ref$mapErrors","mapErrors","concat","_len","arguments","basePaths","Array","_key","_","some","b","atIndex","current","index","tail","fromIndex","toIndex","indexA","indexB","activeErrors"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.prefix = prefix;\nexports.unprefix = unprefix;\nexports.pickErrors = pickErrors;\nexports.filter = filter;\nexports.filterAndMapErrors = filterAndMapErrors;\nexports.remove = remove;\nexports.shift = shift;\nexports.unshift = unshift;\nexports.move = move;\nexports.swap = swap;\nexports.inclusiveMapErrors = inclusiveMapErrors;\nexports.isChildPath = exports.EMPTY_ERRORS = void 0;\n\nvar _omitBy = _interopRequireDefault(require(\"lodash/omitBy\"));\n\nvar _pick = _interopRequireDefault(require(\"lodash/pick\"));\n\nvar _paths = require(\"./paths\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EMPTY_ERRORS = Object.freeze({});\nexports.EMPTY_ERRORS = EMPTY_ERRORS;\n\nvar isChildPath = function isChildPath(basePath, path) {\n  return path !== basePath && (0, _paths.inPath)(basePath, path);\n};\n\nexports.isChildPath = isChildPath;\n\nfunction mapKeys(errors, baseName, fn) {\n  if (errors === EMPTY_ERRORS) return errors;\n  var newErrors = {};\n  var workDone = false;\n  Object.keys(errors).forEach(function (path) {\n    var newKey = path;\n\n    if (isChildPath(baseName, path)) {\n      var matches = path.slice(baseName.length).match(/\\[(\\d+)\\](.*)$/);\n      newKey = fn(+matches[1], matches[2] || '', path);\n      if (!workDone && newKey !== path) workDone = true;\n    }\n\n    newErrors[newKey] = errors[path];\n  });\n  return workDone ? newErrors : errors;\n}\n\nvar prefixName = function prefixName(name, baseName) {\n  return baseName + (!name || name[0] === '[' ? '' : '.') + name;\n};\n\nfunction prefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    result[prefixName(path, baseName)] = errors[path];\n  });\n  return result;\n}\n\nfunction unprefix(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    var shortened = path.slice(baseName.length).replace(/^\\./, '');\n    result[shortened] = errors[path];\n  });\n  return result;\n}\n\nfunction pickErrors(errors, names) {\n  if (!names.length) return errors;\n  return (0, _pick.default)(errors, names);\n}\n\nfunction filter(errors, baseName) {\n  var paths = Object.keys(errors);\n  var result = {};\n  paths.forEach(function (path) {\n    if (isChildPath(baseName, path)) {\n      result[path] = errors[path];\n    }\n  });\n  return result;\n}\n\nfunction filterAndMapErrors(_ref) {\n  var errors = _ref.errors,\n      names = _ref.names,\n      resolveNames = _ref.resolveNames,\n      _ref$mapErrors = _ref.mapErrors,\n      mapErrors = _ref$mapErrors === void 0 ? pickErrors : _ref$mapErrors;\n  if (!errors || errors === EMPTY_ERRORS) return errors;\n  names = resolveNames ? resolveNames() : names;\n  return mapErrors(errors, names ? [].concat(names) : []);\n}\n\nfunction remove(errors) {\n  for (var _len = arguments.length, basePaths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    basePaths[_key - 1] = arguments[_key];\n  }\n\n  return (0, _omitBy.default)(errors, function (_, path) {\n    return basePaths.some(function (b) {\n      return (0, _paths.inPath)(b, path);\n    });\n  });\n}\n\nfunction shift(errors, baseName, atIndex) {\n  var current = baseName + \"[\" + atIndex + \"]\";\n  return mapKeys(remove(errors, current), baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction unshift(errors, baseName, atIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index > atIndex) {\n      return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction move(errors, baseName, fromIndex, toIndex) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (fromIndex > toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // increment everything above the pivot\n\n      if (index >= toIndex && index < fromIndex) return baseName + \"[\" + (index + 1) + \"]\" + tail;\n    } else if (fromIndex < toIndex) {\n      if (index === fromIndex) return baseName + \"[\" + toIndex + \"]\" + tail; // decrement everything above the from item we moved\n\n      if (index >= fromIndex && index < toIndex) return baseName + \"[\" + (index - 1) + \"]\" + tail;\n    }\n\n    return null;\n  });\n}\n\nfunction swap(errors, baseName, indexA, indexB) {\n  return mapKeys(errors, baseName, function (index, tail) {\n    if (index === indexA) return baseName + \"[\" + indexB + \"]\" + tail;\n    if (index === indexB) return baseName + \"[\" + indexA + \"]\" + tail;\n    return null;\n  });\n}\n\nfunction inclusiveMapErrors(errors, names) {\n  if (!names.length || errors === EMPTY_ERRORS) return EMPTY_ERRORS;\n  var activeErrors = {};\n  var paths = Object.keys(errors);\n  names.forEach(function (name) {\n    paths.forEach(function (path) {\n      if (errors[path] && (0, _paths.inPath)(name, path)) {\n        activeErrors[path] = errors[path];\n      }\n    });\n  });\n  return activeErrors;\n}"]},"metadata":{},"sourceType":"script"}